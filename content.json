{"pages":[],"posts":[{"title":"Hexo个人博客搭建简易教程","text":"寻思折腾搭建个个人博客，使用了github上免费的托管服务，和支持丰富主题的Hexo静态博客框架。 因为githubpage只支持静态代码，基本原理就是通过hexo插件，由hexo主题提供样式，个人markdown文章作为文章来源，生成静态网站资源上传到github。大致步骤分为三步： hexo环境配置 静态网站生成 上传GithubPage hexo环境配置hexo是基于nodejs运行的插件。所以需要前置需要下载nodejs运行环境，nodejs因为更新过快版本复杂，通常需要下载nvm来管理。 需要先下载nvm（node version meme node版本管理工具）curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh，在命令行调用nvm执行nvm install stable自动安装最新稳定版nodejs，最后使用nodejs的包管理工具（类似yum）npm安装hexonpm install hexo-cli -g。 静态网站生成静态网站生成需要单独文件夹来存放资源文件，新建blog文件夹。在文件夹内调用hexo init初始化hexo项目结构。 123456789├── _config.yml # 配置文件，网站的标题、作者等基本信息编辑├── package.json├─node_modules├─public # 静态网站生成目录，该目录即博客实际资源文件├─scaffolds # 脚手架，模版├─source│ └─_posts # 文章来源目录，博客文章内容来源└─themes └─landscape # landscape主题，默认主题 增加第一篇文章hexo new &quot;标题&quot;即在_post中相应增加了一篇文章。 hexo server来启动服务器预览效果。 上传GithubPage不仔细介绍了，这里不必一定上传GithubPage，调用hexo generate即时根据source下文件生成的public网站静态文件在多数托管服务器上都能使用。 优化推荐一个hexo主题icarus，样式简约，字体优雅，支持像评论、广告等博客插件的快速集成。 ppoffice/hexo-theme-icarus: A simple, delicate, and modern theme for the static site generator Hexo.","link":"/2021/03/06/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"title":"JNI简易教程","text":"尝试通过C来计算排序，传递结果回Java函数中。学习Java调用C的方式，可以实现更直接的硬件调用和更好的性能，相较于传统的Java程序还是挺有趣的。 Java中提供了JNI的开发方式。通过声明native的接口协定函数的参数和返回值。通过System.load加载c编译的dll。 声明Java类和接口 123456789101112131415161718192021222324package me.cai7n.jni;public class SortThem { { System.load(&quot;D:\\\\Workspace\\\\devc\\\\JNITEST.dll&quot;); } // native接口 public native int[] sort(int[] arr); // 主逻辑 public static void main(String[] args) { int[] arr = new int[]{3,7,1,2,5,9}; int [] newArr = new SortThem().sort(arr); System.out.println(&quot;Java: &quot;); for(int i : newArr) { System.out.print(&quot; &quot;+i); } System.out.println(); }} 编译Java类，自动根据native生成c模版代码 123&gt; javac SortThem.java// 返回到src根目录&gt; javah -classpath . me.cai7n.jni.SortThem 实现c的排序算法并编译dll，主要需要把相关的.h源文件放一起，修改引用和接口内的逻辑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &quot;jni.h&quot;#include &quot;me_cai7n_jni_SortThem.h&quot;#include &lt;stdio.h&gt;JNIEXPORT jintArray JNICALL Java_me_cai7n_jni_SortThem_sort (JNIEnv *a, jobject b, jintArray c) { jsize len = (*a)-&gt;GetArrayLength(a, c); jint * data = (*a)-&gt;GetIntArrayElements(a, c, 0); { int i; printf(&quot;c origin:&quot;); for(i=0;i&lt;6;i++) { printf(&quot;%d &quot;, data[i]); } printf(&quot;\\n&quot;); } { int n=6; int i,j,temp; //两个for循环，每次取出一个元素跟数组的其他元素比较 //将最大的元素排到最后。 for(j=0;j&lt;n-1;j++) { //外循环一次，就排好一个数，并放在后面， //所以比较前面n-j-1个元素即可 for(i=0;i&lt;n-j-1;i++) { if(data[i]&gt;data[i+1]) { temp = data[i]; data[i] = data[i+1]; data[i+1] = temp; } } } } { int i=0; for(i=0;i&lt;6;i++) { printf(&quot;%d &quot;, data[i]); } printf(&quot;\\n&quot;); } //根据int数组个数来创建一个jintArray jintArray newIntArray = (*a)-&gt;NewIntArray(a, 6); //把jint指针中的元素设置到jintArray对象中 (*a)-&gt;SetIntArrayRegion(a, newIntArray, 0, 6, data); //返回jintArray对象 return newIntArray; } 编译成dll后，放到Java代码load的位置，运行Java类 1234Java: 1 2 3 5 7 9c origin:3 7 1 2 5 9 1 2 3 5 7 9 可以发现c打印的在java返回打印之后打印。","link":"/2021/03/07/JNI%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"title":"clone中值传递和引用传递的问题","text":"clone方法用于拷贝出一个存在对象的副本，改变其中一个的属性不会影响另一个。Person p1 = p2;使用赋值操作将p2赋值给p1，并没有创建一个新的对象，而是两个p1，p2变量关联到同一个引用。而Object的clone()方法，实现了各个属性的复制。 Person p1 = p2.clone(); 按照网上参考文档中。p2中的基本变量将复制到p1中，改变p2或p1的变量不会影响另一个对象。但是存在Person中引用数据类型的变量还是会引用同一个对象，造成互相影响。如下例操作： 123456789101112131415161718class Person{ String name; int age; Attribute attribute; // 引用类型}class Test{ public void main(String[] args){ Person p1 = new Person(); p1.name ... // 赋值p1 // 拷贝 Person p2 = p1.clone(); p1.attribute = null; AssertIsNull(p2.attribute); //是null 还是非null }} 实际测试下来并非如此。 照理说调用原对象的clone()方法，Date类型的字段在拷贝后的对象中只是保存了和原对象一样的引用地址，这样，如果拷贝的对象更新了修改日期字段，原对象的字段也会被更新，但事实结果却相反。更新其中的Date字段，并不会影响另外一个。尝试了自定义的非基本类型，加入到User字段中，依然是互不影响。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142public class CopyTest{ public static void main(String[] args) throws CloneNotSupportedException, InterruptedException { Date now = new Date(); User u = new User(); u.date = now; User u2 = (User) u.clone(); // 打印更新前两对象 System.out.println(System.identityHashCode(u.date)); System.out.println(System.identityHashCode(u2.date)); // 更新其中一个的日期 Thread.sleep(1000);// u2.date = new Date(); u.date = new Date(); // 打印更新后的两对象日期字段 System.out.println(&quot;after&quot;); System.out.println(System.identityHashCode(u.date)); System.out.println(System.identityHashCode(u2.date)); System.out.println(u.date.getTime()); System.out.println(u2.date.getTime()); }}/** * 用户bean */class User implements Clonable{ String name; Date date; @Override public Object clone() throws CloneNotSupportedException { User c = (User) super.clone(); // if(c.date!=null)// c.date = (Date) c.date.clone(); return c; } } 打印结果： 123456721339270022133927002after1836019240213392700215529067562211552906755211 可能是版本高做了改进的原因，后续考虑在低版本的1.5或1.6的jdk上尝试。 https://blog.csdn.net/qq_33314107/article/details/80271963 java对象clone()方法","link":"/2021/03/07/clone%E4%B8%AD%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"Java元注解参考","text":"注解是 Java 5 的一个新特性。注解是插入你代码中的一种注释或者说是一种元数据（meta data）。这些注解信息可以在编译期使用预编译工具进行处理（pre-compiler tools），也可以在运行期使用 Java 反射机制进行处理。 Java中通过元注解的方式标记注解，也就是注解的注解。元注解有三个。 @interface注解定义 1234567@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface MyAnnotation { public String name(); public String value();} @Retention注解保留周期 12345// @Rentention的值有// 1、RetentionPolicy.SOURCE：注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃；// 2、RetentionPolicy.CLASS：注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期；// 3、RetentionPolicy.RUNTIME：注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在；// 这3个生命周期分别对应于：Java源文件(.java文件) ---&gt; .class文件 ---&gt; 内存中的字节码。 @Target注解位置 12345678910111213141516171819202122232425// 描述类// @Target(ElementType.TYPE)Class aClass = TheClass.class;Annotation annotation = aClass.getAnnotation(MyAnnotation.class);// 描述方法// @Target(ElementType.METHOD)Method method = ... //获取方法对象Annotation[] annotations = method.getDeclaredAnnotations();// 描述变量// @Target(ElementType.FIELD)Field field = ... //获取方法对象&lt;/pre&gt;&lt;pre&gt;Annotation[] annotations = field.getDeclaredAnnotations();// 描述参数// @Target(ElementType.PARAMETER)Method method = ... //获取方法对象Annotation[][] parameterAnnotations = method.getParameterAnnotations();// @Target(ElementType.CONSTRUCTOR)// @Target(ElementType.LOCAL_VARIABLE)// @Target(ElementType.ANNOTATION_TYPE)// @Target(ElementType.PACKAGE)// @Target(ElementType.TYPE_PARAMETER) 参考 http://ifeve.com/java-reflection-8-annotation/ Java反射（翻译）","link":"/2021/03/07/Java%E5%85%83%E6%B3%A8%E8%A7%A3%E5%8F%82%E8%80%83/"},{"title":"Java动态代理实现通用逻辑处理","text":"代理即是借助非本体来完成一件事。这里Java的动态代理，即通过Proxy类生成代理对象，来运行方法并在方法层面上处理额外的数据（办理手续）。 这里运行的方法不能是随意的，得符合Java反射规定Java接口来调用。本质是通过拷贝实例字节码到接口字节码。 与静态代理不同的是，静态代理使用继承关系，需要为每个需要代理的类设计代理类。动态代理可以灵活代理实现自接口的所有类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class InvokeTest{ // 首先得声明行为接口，为本体对象和代理对象服务。 private static interface Human { void work(); void sleep(); } // 声明实体类 private static class Man implements Human { @Override public void work() { System.out.println(&quot;搬砖&quot;); try { Thread.sleep(3*1000); // 工作3秒 } catch (InterruptedException e) { e.printStackTrace(); } } @Override public void sleep() { System.out.println(&quot;睡觉&quot;); try { Thread.sleep(2*1000); } catch (InterruptedException e) { e.printStackTrace(); } } } // 代理类用来记录方法执行即主体动作执行的时间 private static class MyInvokeHandler implements InvocationHandler { private Object inner; public MyInvokeHandler(Object obj) { this.inner = obj; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { long msStart = System.currentTimeMillis(); System.out.println(&quot;log 开始&quot;+method.getName()); method.invoke(inner, args); System.out.println(&quot;log 结束&quot;+method.getName()+&quot;，用时&quot;+(System.currentTimeMillis()-msStart)+&quot;毫秒&quot;); System.out.println(); return null; } } // Main public static void main(String[] args) { InvocationHandler handler = new MyInvokeHandler(new Man()); //代理类中加入实体 Human proxy = (Human) Proxy.newProxyInstance(Human.class.getClassLoader(), new Class[]{Human.class}, handler); // 得到和实体相同的代理对象，有声明接口特质，实际执行由Handler Invoke执行 proxy.work(); proxy.sleep(); }} https://www.liaoxuefeng.com/wiki/1252599548343744/1264804593397984 廖雪峰Java动态代理","link":"/2021/03/07/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91%E5%A4%84%E7%90%86/"}],"tags":[],"categories":[{"name":"折腾","slug":"折腾","link":"/categories/%E6%8A%98%E8%85%BE/"},{"name":"Java","slug":"Java","link":"/categories/Java/"}]}