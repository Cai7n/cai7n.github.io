{"pages":[],"posts":[{"title":"Hexo个人博客搭建简易教程","text":"寻思折腾搭建个个人博客，使用了github上免费的托管服务，和支持丰富主题的Hexo静态博客框架。 因为githubpage只支持静态代码，基本原理就是通过hexo插件，由hexo主题提供样式，个人markdown文章作为文章来源，生成静态网站资源上传到github。大致步骤分为三步： hexo环境配置 静态网站生成 上传GithubPage hexo环境配置hexo是基于nodejs运行的插件。所以需要前置需要下载nodejs运行环境，nodejs因为更新过快版本复杂，通常需要下载nvm来管理。 需要先下载nvm（node version meme node版本管理工具）curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh，在命令行调用nvm执行nvm install stable自动安装最新稳定版nodejs，最后使用nodejs的包管理工具（类似yum）npm安装hexonpm install hexo-cli -g。 静态网站生成静态网站生成需要单独文件夹来存放资源文件，新建blog文件夹。在文件夹内调用hexo init初始化hexo项目结构。 123456789├── _config.yml # 配置文件，网站的标题、作者等基本信息编辑├── package.json├─node_modules├─public # 静态网站生成目录，该目录即博客实际资源文件├─scaffolds # 脚手架，模版├─source│ └─_posts # 文章来源目录，博客文章内容来源└─themes └─landscape # landscape主题，默认主题 增加第一篇文章hexo new &quot;标题&quot;即在_post中相应增加了一篇文章。 hexo server来启动服务器预览效果。 上传GithubPage不仔细介绍了，这里不必一定上传GithubPage，调用hexo generate即时根据source下文件生成的public网站静态文件在多数托管服务器上都能使用。 优化推荐一个hexo主题icarus，样式简约，字体优雅，支持像评论、广告等博客插件的快速集成。 ppoffice/hexo-theme-icarus: A simple, delicate, and modern theme for the static site generator Hexo.","link":"/2021/03/06/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"title":"JNI简易教程","text":"尝试通过C来计算排序，传递结果回Java函数中。学习Java调用C的方式，可以实现更直接的硬件调用和更好的性能，相较于传统的Java程序还是挺有趣的。 Java中提供了JNI的开发方式。通过声明native的接口协定函数的参数和返回值。通过System.load加载c编译的dll。 声明Java类和接口 123456789101112131415161718192021222324package me.cai7n.jni;public class SortThem { { System.load(&quot;D:\\\\Workspace\\\\devc\\\\JNITEST.dll&quot;); } // native接口 public native int[] sort(int[] arr); // 主逻辑 public static void main(String[] args) { int[] arr = new int[]{3,7,1,2,5,9}; int [] newArr = new SortThem().sort(arr); System.out.println(&quot;Java: &quot;); for(int i : newArr) { System.out.print(&quot; &quot;+i); } System.out.println(); }} 编译Java类，自动根据native生成c模版代码 123&gt; javac SortThem.java// 返回到src根目录&gt; javah -classpath . me.cai7n.jni.SortThem 实现c的排序算法并编译dll，主要需要把相关的.h源文件放一起，修改引用和接口内的逻辑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &quot;jni.h&quot;#include &quot;me_cai7n_jni_SortThem.h&quot;#include &lt;stdio.h&gt;JNIEXPORT jintArray JNICALL Java_me_cai7n_jni_SortThem_sort (JNIEnv *a, jobject b, jintArray c) { jsize len = (*a)-&gt;GetArrayLength(a, c); jint * data = (*a)-&gt;GetIntArrayElements(a, c, 0); { int i; printf(&quot;c origin:&quot;); for(i=0;i&lt;6;i++) { printf(&quot;%d &quot;, data[i]); } printf(&quot;\\n&quot;); } { int n=6; int i,j,temp; //两个for循环，每次取出一个元素跟数组的其他元素比较 //将最大的元素排到最后。 for(j=0;j&lt;n-1;j++) { //外循环一次，就排好一个数，并放在后面， //所以比较前面n-j-1个元素即可 for(i=0;i&lt;n-j-1;i++) { if(data[i]&gt;data[i+1]) { temp = data[i]; data[i] = data[i+1]; data[i+1] = temp; } } } } { int i=0; for(i=0;i&lt;6;i++) { printf(&quot;%d &quot;, data[i]); } printf(&quot;\\n&quot;); } //根据int数组个数来创建一个jintArray jintArray newIntArray = (*a)-&gt;NewIntArray(a, 6); //把jint指针中的元素设置到jintArray对象中 (*a)-&gt;SetIntArrayRegion(a, newIntArray, 0, 6, data); //返回jintArray对象 return newIntArray; } 编译成dll后，放到Java代码load的位置，运行Java类 1234Java: 1 2 3 5 7 9c origin:3 7 1 2 5 9 1 2 3 5 7 9 可以发现c打印的在java返回打印之后打印。","link":"/2021/03/07/JNI%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"title":"clone中值传递和引用传递的问题","text":"clone方法用于拷贝出一个存在对象的副本，改变其中一个的属性不会影响另一个。Person p1 = p2;使用赋值操作将p2赋值给p1，并没有创建一个新的对象，而是两个p1，p2变量关联到同一个引用。而Object的clone()方法，实现了各个属性的复制。 Person p1 = p2.clone(); 按照网上参考文档中。p2中的基本变量将复制到p1中，改变p2或p1的变量不会影响另一个对象。但是存在Person中引用数据类型的变量还是会引用同一个对象，造成互相影响。如下例操作： 123456789101112131415161718class Person{ String name; int age; Attribute attribute; // 引用类型}class Test{ public void main(String[] args){ Person p1 = new Person(); p1.name ... // 赋值p1 // 拷贝 Person p2 = p1.clone(); p1.attribute = null; AssertIsNull(p2.attribute); //是null 还是非null }} 实际测试下来并非如此。 照理说调用原对象的clone()方法，Date类型的字段在拷贝后的对象中只是保存了和原对象一样的引用地址，这样，如果拷贝的对象更新了修改日期字段，原对象的字段也会被更新，但事实结果却相反。更新其中的Date字段，并不会影响另外一个。尝试了自定义的非基本类型，加入到User字段中，依然是互不影响。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142public class CopyTest{ public static void main(String[] args) throws CloneNotSupportedException, InterruptedException { Date now = new Date(); User u = new User(); u.date = now; User u2 = (User) u.clone(); // 打印更新前两对象 System.out.println(System.identityHashCode(u.date)); System.out.println(System.identityHashCode(u2.date)); // 更新其中一个的日期 Thread.sleep(1000);// u2.date = new Date(); u.date = new Date(); // 打印更新后的两对象日期字段 System.out.println(&quot;after&quot;); System.out.println(System.identityHashCode(u.date)); System.out.println(System.identityHashCode(u2.date)); System.out.println(u.date.getTime()); System.out.println(u2.date.getTime()); }}/** * 用户bean */class User implements Clonable{ String name; Date date; @Override public Object clone() throws CloneNotSupportedException { User c = (User) super.clone(); // if(c.date!=null)// c.date = (Date) c.date.clone(); return c; } } 打印结果： 123456721339270022133927002after1836019240213392700215529067562211552906755211 可能是版本高做了改进的原因，后续考虑在低版本的1.5或1.6的jdk上尝试。 https://blog.csdn.net/qq_33314107/article/details/80271963 java对象clone()方法","link":"/2021/03/07/clone%E4%B8%AD%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"Java元注解参考","text":"注解是 Java 5 的一个新特性。注解是插入你代码中的一种注释或者说是一种元数据（meta data）。这些注解信息可以在编译期使用预编译工具进行处理（pre-compiler tools），也可以在运行期使用 Java 反射机制进行处理。 Java中通过元注解的方式标记注解，也就是注解的注解。元注解有三个。 @interface注解定义 1234567@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface MyAnnotation { public String name(); public String value();} @Retention注解保留周期 12345// @Rentention的值有// 1、RetentionPolicy.SOURCE：注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃；// 2、RetentionPolicy.CLASS：注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期；// 3、RetentionPolicy.RUNTIME：注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在；// 这3个生命周期分别对应于：Java源文件(.java文件) ---&gt; .class文件 ---&gt; 内存中的字节码。 @Target注解位置 12345678910111213141516171819202122232425// 描述类// @Target(ElementType.TYPE)Class aClass = TheClass.class;Annotation annotation = aClass.getAnnotation(MyAnnotation.class);// 描述方法// @Target(ElementType.METHOD)Method method = ... //获取方法对象Annotation[] annotations = method.getDeclaredAnnotations();// 描述变量// @Target(ElementType.FIELD)Field field = ... //获取方法对象&lt;/pre&gt;&lt;pre&gt;Annotation[] annotations = field.getDeclaredAnnotations();// 描述参数// @Target(ElementType.PARAMETER)Method method = ... //获取方法对象Annotation[][] parameterAnnotations = method.getParameterAnnotations();// @Target(ElementType.CONSTRUCTOR)// @Target(ElementType.LOCAL_VARIABLE)// @Target(ElementType.ANNOTATION_TYPE)// @Target(ElementType.PACKAGE)// @Target(ElementType.TYPE_PARAMETER) 参考 http://ifeve.com/java-reflection-8-annotation/ Java反射（翻译）","link":"/2021/03/07/Java%E5%85%83%E6%B3%A8%E8%A7%A3%E5%8F%82%E8%80%83/"},{"title":"Java动态代理实现通用逻辑处理","text":"代理即是借助非本体来完成一件事。这里Java的动态代理，即通过Proxy类生成代理对象，来运行方法并在方法层面上处理额外的数据（办理手续）。 这里运行的方法不能是随意的，得符合Java反射规定Java接口来调用。本质是通过拷贝实例字节码到接口字节码。 与静态代理不同的是，静态代理使用继承关系，需要为每个需要代理的类设计代理类。动态代理可以灵活代理实现自接口的所有类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class InvokeTest{ // 首先得声明行为接口，为本体对象和代理对象服务。 private static interface Human { void work(); void sleep(); } // 声明实体类 private static class Man implements Human { @Override public void work() { System.out.println(&quot;搬砖&quot;); try { Thread.sleep(3*1000); // 工作3秒 } catch (InterruptedException e) { e.printStackTrace(); } } @Override public void sleep() { System.out.println(&quot;睡觉&quot;); try { Thread.sleep(2*1000); } catch (InterruptedException e) { e.printStackTrace(); } } } // 代理类用来记录方法执行即主体动作执行的时间 private static class MyInvokeHandler implements InvocationHandler { private Object inner; public MyInvokeHandler(Object obj) { this.inner = obj; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { long msStart = System.currentTimeMillis(); System.out.println(&quot;log 开始&quot;+method.getName()); method.invoke(inner, args); System.out.println(&quot;log 结束&quot;+method.getName()+&quot;，用时&quot;+(System.currentTimeMillis()-msStart)+&quot;毫秒&quot;); System.out.println(); return null; } } // Main public static void main(String[] args) { InvocationHandler handler = new MyInvokeHandler(new Man()); //代理类中加入实体 Human proxy = (Human) Proxy.newProxyInstance(Human.class.getClassLoader(), new Class[]{Human.class}, handler); // 得到和实体相同的代理对象，有声明接口特质，实际执行由Handler Invoke执行 proxy.work(); proxy.sleep(); }} https://www.liaoxuefeng.com/wiki/1252599548343744/1264804593397984 廖雪峰Java动态代理","link":"/2021/03/07/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91%E5%A4%84%E7%90%86/"},{"title":"BIO,NIO到多路复用","text":"BIO、NIO到多路复用Socket的发展进程： 1 - 阻塞（原始形象的连接方式accept、read、write，无法处理多个连接） 2 - 阻塞多线程（可以同时处理多个连接，但消耗内存，线程切换损失） 3 - 非阻塞（accept后马上返回，单线程可以处理多个连接，但每个连接是否有数据需要调用系统轮询） 4.1- 多路复用selector（一次系统调用传递所有要轮训的事件，用户态到内核态一次，缺点是即使没有新注册事件，每次仍需要重复传递所有相同的注册事件） 4.2 - poll（系统调用接口中注册事件容器改为链表可传递无限的事件） 4.3 - epoll（内核空间开辟内存，存注册的事件，用户仅传递变化的事件部分；另外注册事件通过硬件中断自动事件驱动进入到另一块内存，用户获取的时候直接返回不用用户轮训或系统轮训） 5 - 多线程多路复用（boss单线程负责accept，工作线程处理大量的读写任务） 1 - 阻塞单线程 1234567891011121314151617181920212223242526272829303132333435363738/** * 创建serverSocket 并绑定 8080端口 * 在系统内核中要经过以下几步来完成Java语言的 “new ServerSocket(8080)”。 * 1. socket() = fd6 获取文件描述符； * 2. bind(fd6,8080) 文件描述符与端口绑定； * 3. listen(fd6) 监听文件描述符 */ServerSocket serverSocket = new ServerSocket(8080);System.out.println(&quot;step1 : new ServerSocket(8080) &quot;);/** * 接受socket客户端请求连接 * accept命令是一个阻塞命令， 只有当有客户端连接进入时候， 才会结束阻塞状态。 * 当有客户端连接进入时候 accept(fd6) ==&gt;fd7 与客户端创建的随机端口号和随机文件描述符连接 */Socket socket = serverSocket.accept();//阻塞状态1System.out.println(&quot;acceptSocketClient:&quot; + socket.getPort());/** * 获取阻塞连接输出 输入流 */InputStream inputStream = socket.getInputStream();/** * 创建出入缓冲区 */BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));String text = null;/** * read命令也是一个阻塞命令，等待客户端数据传入。 * 客户端输入传入后结束阻塞状态。 * * read(fd7) 读取客户端写入到文件描述符7中的文件。 */while (StringUtils.isNotEmpty((text = bufferedReader.readLine() ))){//阻塞状态2 System.out.println(&quot;acceptSocketClient:&quot; + socket.getPort() + &quot;---&quot; + text);} 2 - 阻塞多线程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 创建serverSocket 并绑定 8080端口 * 在系统内核中要经过以下几步来完成Java语言的 “new ServerSocket(8080)”。 * 1. socket() = fd6 获取文件描述符； * 2. bind(fd6,8080) 文件描述符与端口绑定； * 3. listen(fd6) 监听文件描述符 */ServerSocket serverSocket = new ServerSocket(8080);System.out.println(&quot;step1 : new ServerSocket(8080) &quot;);while (true){ /** * 接受socket客户端请求连接 * * accept命令是一个阻塞命令，只有当有客户端连接进入时候， 才会结束阻塞状态。 * 当有客户端连接进入时候 accept(fd6) ==&gt;fd7 与客户端创建的随机端口号和随机文件描述符连接 */ Socket socket = serverSocket.accept();//阻塞状态1 System.out.println(&quot;acceptSocketClient:&quot; + socket.getPort()); /** * 每次进入一个客户端则创建一个线程去处理数据 * 因为线程的创建是非常消耗资源的 * 而且线程创建数量也是有限的，在C10K问题下，处理更多的TCP连接请求。 */ new Thread(new Runnable() { @Override public void run() { /** * 获取阻塞连接输出 输入流 */ InputStream inputStream = null; try { inputStream = socket.getInputStream(); /** * 创建出入缓冲区 */ BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); String text = null; /** * read命令也是一个阻塞命令，等待客户端数据传入。 * 客户端输入传入后结束阻塞状态。 * * read(fd7) 读取客户端写入到文件描述符7中的文件。 */ while (StringUtils.isNotEmpty((text = bufferedReader.readLine() ))){//阻塞状态2 System.out.println(&quot;acceptSocketClient:&quot; + socket.getPort() + &quot;---&quot; + text); } } catch (IOException e) { e.printStackTrace(); } } }).start();} 3 NIO非阻塞 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// 用于存放所有客户端连接 List&lt;SocketChannel&gt; channels = new LinkedList&lt;SocketChannel&gt;(); //JDK中区别于 Socket 的新IO体系。 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();//打开一个ServerSocket通道 /** * //绑定端口 */ serverSocketChannel.bind(new InetSocketAddress(8080)); System.out.println(&quot;step1 : new ServerSocket(8080) &quot;); /** * 设置为非阻塞IO模型 */ serverSocketChannel.configureBlocking(false);//设置为非阻塞IO模型 while (true){ Thread.currentThread().sleep(1000);//每次循环停顿一秒 /** * //获取客户端连接请求------非阻塞状态 * 设置客户端为非阻塞状态 */ SocketChannel socketChannel = serverSocketChannel.accept(); if(socketChannel == null){//没有客户端连接打印空信息 System.out.println(&quot;null client...&quot;); }else{//有客户端连接 socketChannel.configureBlocking(false);//设置客户端连接为非阻塞状态 int clientPort = socketChannel.socket().getPort();//获取客户端的随机端口号 System.out.println(&quot;acceptSocketClient:&quot; + clientPort);//打印客户端随机端口号 /** * //把新进入的客户端放入队列中 * 这一步的目的是为了让客户端获取和从客户端获取数据区分开操作。 */ channels.add(socketChannel); } /** * //开启一个4096位的公用缓冲区，4KB * 在实际使用的过程中一般一个SocketClannel通道对应一个缓冲区 * 且缓冲区大小为动态设置,因为4KB缓冲区存在不够用情况 * *****可以在堆里面----可以在堆外面 * * 1.建议每个通道对应一个ByteBuffer进行数据处理； * 2.数据是按照流的形式进入的通道，每个ByteBuffer中存在一组指针。指向用户数据流在通道中的位置； * 3.当数据从客户端写入到ByteBuffer后，会有一个flip指针动态移动，始终指向数据结尾。 * 4.当处理客户端数据线程线程需要从ByteBuffer读取数据时，需要用一个limit指针指向flip指针当前的位置（数据结尾处）， * 同时反转flip指针至ByteBuffer数据开头（数据开始出）。limit指针和flip指针之间的距离就是本次数据传输的数据量大小。 * 5.ByteBuffer是一个缓冲区，可以减少碎片，重复利用也可以减少GC频繁分配的问题。 */ ByteBuffer byteBuffer = ByteBuffer.allocateDirect(4096); /** * 在这个阶段，循环每个连接进入的客户端， * 判断每个客户端是否有数据传入 * 这个步骤是严格的串行化处理的。 */ for(SocketChannel channel : channels){ /** * //缓冲区中的数据个数，该个数存在几种情况 * &lt;0 （-1）客户端错误，关闭了连接或者超时等 * =0 客户端无输入写入，跳出不做处理 * &gt;0 客户端有数据写入 */ int readNum = channel.read(byteBuffer);//把客户端传入的数据读取到缓冲区----不再阻塞 if(readNum &lt; 0){ channel.close(); channels.remove(channel); }else if(readNum == 0){ continue; }else { byteBuffer.flip();//缓冲区中指针反转，准备读取数据 byte[] bytes = new byte[readNum];//创建一个缓冲区中数据大小的字节数组 byteBuffer.get(bytes);//把缓冲区中的数据写入字节数组。 String str = new String(bytes);//字节数组中的数据转成可用于操作的String类型 System.out.println(&quot;acceptSocketClientData:&quot; + channel.socket().getPort() + &quot;---&quot; + str); /** * //由于是众多的client公用一个缓冲区， * 因此在每次循环完一个客户端数据后要把缓冲区清空 */ byteBuffer.clear(); } } 4 多路复用-单线程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * 初始化服务器端信息 */ private void initServerSocket(){ try { serverSocketChannel = ServerSocketChannel.open(); serverSocketChannel.bind(new InetSocketAddress(serverPort));//绑定端口号 System.out.println(&quot;step1 : new ServerSocket(&quot; + serverPort+ &quot;) &quot;); serverSocketChannel.configureBlocking(false);//设置服务端非阻塞模式 /** * //打开多路复用器 */ selector = Selector.open(); /** * 把服务端注册到多路复用器当中，并监听一个网络行为---》OP_ACCEPT * * Interest Set * 监听的Channel通道触发了一个事件意思是该事件已经就绪。 * 一个channel成功连接到另一个服务器称为”连接就绪“。 * 一个server socket channel准备号接收新进入的连接称为”接收就绪“。 * 一个有数据可读的通道可以说是”读就绪“。 * 一个等待写数据的通道可以说是”写就绪“。 * 这四种事件用SelectionKey的四个常量来表示： * SelectionKey.OP_CONNECT * SelectionKey.OP_ACCEPT * SelectionKey.OP_READ * SelectionKey.OP_WRITE */ serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); } catch (IOException e) { e.printStackTrace(); } } public void start(){ initServerSocket(); System.out.println(&quot;服务端已经启动..........&quot;); try { while (true){ /** * select方法---》 * 参数： * 如果为正数，则阻塞最长&lt;tt&gt;超时&lt;/tt&gt;在等待一个通道准备就绪； * 如果为零，则无限期阻塞； * *不能为负数 * 返回值： 钥匙的数量，可能是零，其就绪操作集已更新 */ if(selector.select(0) &gt; 0){//无限阻塞，如果有数据或者有事件传入行为到达则返回值大于0 /** * 返回有数据传入或有事件的SocketChannel集合。 * 从多路复用器取出有效的连接-selectionKeys- */ Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator(); /** * 循环迭代每个有数据传入或有事件的SocketChannel, * 并根据他们的行为做特殊处理 */ while (iterator.hasNext()){ SelectionKey selectionKey = iterator.next();//获取到选择秘钥 /** * 获取之后从原迭代器中删除，防止重复循环 */ iterator.remove(); if(selectionKey.isConnectable()){ System.out.println(&quot;---------------selectionKey.isConnectable()......&quot;); }else if(selectionKey.isAcceptable()){//客户端请求连接事件 acceptHandler(selectionKey); }else if(selectionKey.isReadable()){//客户端数据到达事件 readHandler(selectionKey); }else if(selectionKey.isValid()){ System.out.println(&quot;---------------selectionKey.isValid()......&quot;); }else if(selectionKey.isWritable()){ System.out.println(&quot;---------------selectionKey.isWritable()......&quot;); } } } } } catch (IOException e) { e.printStackTrace(); } } 5 - 多路复用多线程 12345678910111213141516int serverPort = 8080; int workerNum = 3; System.out.println(&quot;准备启动服务端端口号：&quot; + serverPort + &quot;---准备启动worker数量：&quot; + workerNum); SocketServerSelectorMultiplexingThreads server = new SocketServerSelectorMultiplexingThreads(serverPort,workerNum); NioThread bossThreadRunnable = new NioThread(server.getBossSelector(),workerNum); Thread bossThread = new Thread(bossThreadRunnable); bossThread.start(); Thread.currentThread().sleep(2000); Thread workerThread = null; Selector[] workerSelectors = server.getWorkerSelectors(); for(Selector selector : workerSelectors){ NioThread workerNioThread = new NioThread(selector); workerThread = new Thread(workerNioThread); workerThread.start(); } 参考 https://blog.csdn.net/yueaini10000/article/details/108748208?spm=1001.2014.3001.5501","link":"/2021/06/16/BIO-NIO%E5%88%B0%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"},{"title":"数据库隔离级别简释","text":"","link":"/2021/06/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%AE%80%E9%87%8A/"}],"tags":[],"categories":[{"name":"折腾","slug":"折腾","link":"/categories/%E6%8A%98%E8%85%BE/"},{"name":"Java","slug":"Java","link":"/categories/Java/"}]}